{"ast":null,"code":"import { __read, __rest, __assign } from 'tslib';\nimport { startAnimation } from '../../animation/utils/transitions.mjs';\nimport { setTarget } from './setters.mjs';\nimport { resolveVariant } from './variants.mjs';\nimport { isTransformProp } from '../html/utils/transform.mjs';\nimport { isWillChangeMotionValue } from '../../value/use-will-change/is.mjs';\n\nfunction animateVisualElement(visualElement, definition, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  visualElement.notifyAnimationStart(definition);\n  var animation;\n\n  if (Array.isArray(definition)) {\n    var animations = definition.map(function (variant) {\n      return animateVariant(visualElement, variant, options);\n    });\n    animation = Promise.all(animations);\n  } else if (typeof definition === \"string\") {\n    animation = animateVariant(visualElement, definition, options);\n  } else {\n    var resolvedDefinition = typeof definition === \"function\" ? resolveVariant(visualElement, definition, options.custom) : definition;\n    animation = animateTarget(visualElement, resolvedDefinition, options);\n  }\n\n  return animation.then(function () {\n    return visualElement.notifyAnimationComplete(definition);\n  });\n}\n\nfunction animateVariant(visualElement, variant, options) {\n  var _a;\n\n  if (options === void 0) {\n    options = {};\n  }\n\n  var resolved = resolveVariant(visualElement, variant, options.custom);\n  var _b = (resolved || {}).transition,\n      transition = _b === void 0 ? visualElement.getDefaultTransition() || {} : _b;\n\n  if (options.transitionOverride) {\n    transition = options.transitionOverride;\n  }\n  /**\n   * If we have a variant, create a callback that runs it as an animation.\n   * Otherwise, we resolve a Promise immediately for a composable no-op.\n   */\n\n\n  var getAnimation = resolved ? function () {\n    return animateTarget(visualElement, resolved, options);\n  } : function () {\n    return Promise.resolve();\n  };\n  /**\n   * If we have children, create a callback that runs all their animations.\n   * Otherwise, we resolve a Promise immediately for a composable no-op.\n   */\n\n  var getChildAnimations = ((_a = visualElement.variantChildren) === null || _a === void 0 ? void 0 : _a.size) ? function (forwardDelay) {\n    if (forwardDelay === void 0) {\n      forwardDelay = 0;\n    }\n\n    var _a = transition.delayChildren,\n        delayChildren = _a === void 0 ? 0 : _a,\n        staggerChildren = transition.staggerChildren,\n        staggerDirection = transition.staggerDirection;\n    return animateChildren(visualElement, variant, delayChildren + forwardDelay, staggerChildren, staggerDirection, options);\n  } : function () {\n    return Promise.resolve();\n  };\n  /**\n   * If the transition explicitly defines a \"when\" option, we need to resolve either\n   * this animation or all children animations before playing the other.\n   */\n\n  var when = transition.when;\n\n  if (when) {\n    var _c = __read(when === \"beforeChildren\" ? [getAnimation, getChildAnimations] : [getChildAnimations, getAnimation], 2),\n        first = _c[0],\n        last = _c[1];\n\n    return first().then(last);\n  } else {\n    return Promise.all([getAnimation(), getChildAnimations(options.delay)]);\n  }\n}\n/**\n * @internal\n */\n\n\nfunction animateTarget(visualElement, definition, _a) {\n  var _b;\n\n  var _c = _a === void 0 ? {} : _a,\n      _d = _c.delay,\n      delay = _d === void 0 ? 0 : _d,\n      transitionOverride = _c.transitionOverride,\n      type = _c.type;\n\n  var _e = visualElement.makeTargetAnimatable(definition),\n      _f = _e.transition,\n      transition = _f === void 0 ? visualElement.getDefaultTransition() : _f,\n      transitionEnd = _e.transitionEnd,\n      target = __rest(_e, [\"transition\", \"transitionEnd\"]);\n\n  var willChange = visualElement.getValue(\"willChange\");\n  if (transitionOverride) transition = transitionOverride;\n  var animations = [];\n  var animationTypeState = type && ((_b = visualElement.animationState) === null || _b === void 0 ? void 0 : _b.getState()[type]);\n\n  var _loop_1 = function (key) {\n    var value = visualElement.getValue(key);\n    var valueTarget = target[key];\n\n    if (!value || valueTarget === undefined || animationTypeState && shouldBlockAnimation(animationTypeState, key)) {\n      return \"continue\";\n    }\n\n    var valueTransition = __assign({\n      delay: delay\n    }, transition);\n    /**\n     * Make animation instant if this is a transform prop and we should reduce motion.\n     */\n\n\n    if (visualElement.shouldReduceMotion && isTransformProp(key)) {\n      valueTransition = __assign(__assign({}, valueTransition), {\n        type: false,\n        delay: 0\n      });\n    }\n\n    var animation = startAnimation(key, value, valueTarget, valueTransition);\n\n    if (isWillChangeMotionValue(willChange)) {\n      willChange.add(key);\n      animation = animation.then(function () {\n        return willChange.remove(key);\n      });\n    }\n\n    animations.push(animation);\n  };\n\n  for (var key in target) {\n    _loop_1(key);\n  }\n\n  return Promise.all(animations).then(function () {\n    transitionEnd && setTarget(visualElement, transitionEnd);\n  });\n}\n\nfunction animateChildren(visualElement, variant, delayChildren, staggerChildren, staggerDirection, options) {\n  if (delayChildren === void 0) {\n    delayChildren = 0;\n  }\n\n  if (staggerChildren === void 0) {\n    staggerChildren = 0;\n  }\n\n  if (staggerDirection === void 0) {\n    staggerDirection = 1;\n  }\n\n  var animations = [];\n  var maxStaggerDuration = (visualElement.variantChildren.size - 1) * staggerChildren;\n  var generateStaggerDuration = staggerDirection === 1 ? function (i) {\n    if (i === void 0) {\n      i = 0;\n    }\n\n    return i * staggerChildren;\n  } : function (i) {\n    if (i === void 0) {\n      i = 0;\n    }\n\n    return maxStaggerDuration - i * staggerChildren;\n  };\n  Array.from(visualElement.variantChildren).sort(sortByTreeOrder).forEach(function (child, i) {\n    animations.push(animateVariant(child, variant, __assign(__assign({}, options), {\n      delay: delayChildren + generateStaggerDuration(i)\n    })).then(function () {\n      return child.notifyAnimationComplete(variant);\n    }));\n  });\n  return Promise.all(animations);\n}\n\nfunction stopAnimation(visualElement) {\n  visualElement.forEachValue(function (value) {\n    return value.stop();\n  });\n}\n\nfunction sortByTreeOrder(a, b) {\n  return a.sortNodePosition(b);\n}\n/**\n * Decide whether we should block this animation. Previously, we achieved this\n * just by checking whether the key was listed in protectedKeys, but this\n * posed problems if an animation was triggered by afterChildren and protectedKeys\n * had been set to true in the meantime.\n */\n\n\nfunction shouldBlockAnimation(_a, key) {\n  var protectedKeys = _a.protectedKeys,\n      needsAnimating = _a.needsAnimating;\n  var shouldBlock = protectedKeys.hasOwnProperty(key) && needsAnimating[key] !== true;\n  needsAnimating[key] = false;\n  return shouldBlock;\n}\n\nexport { animateVisualElement, sortByTreeOrder, stopAnimation };","map":{"version":3,"names":["__read","__rest","__assign","startAnimation","setTarget","resolveVariant","isTransformProp","isWillChangeMotionValue","animateVisualElement","visualElement","definition","options","notifyAnimationStart","animation","Array","isArray","animations","map","variant","animateVariant","Promise","all","resolvedDefinition","custom","animateTarget","then","notifyAnimationComplete","_a","resolved","_b","transition","getDefaultTransition","transitionOverride","getAnimation","resolve","getChildAnimations","variantChildren","size","forwardDelay","delayChildren","staggerChildren","staggerDirection","animateChildren","when","_c","first","last","delay","_d","type","_e","makeTargetAnimatable","_f","transitionEnd","target","willChange","getValue","animationTypeState","animationState","getState","_loop_1","key","value","valueTarget","undefined","shouldBlockAnimation","valueTransition","shouldReduceMotion","add","remove","push","maxStaggerDuration","generateStaggerDuration","i","from","sort","sortByTreeOrder","forEach","child","stopAnimation","forEachValue","stop","a","b","sortNodePosition","protectedKeys","needsAnimating","shouldBlock","hasOwnProperty"],"sources":["C:/Users/DELL/Downloads/Blog---Frontend-master/Blog---Frontend-master/node_modules/framer-motion/dist/es/render/utils/animation.mjs"],"sourcesContent":["import { __read, __rest, __assign } from 'tslib';\nimport { startAnimation } from '../../animation/utils/transitions.mjs';\nimport { setTarget } from './setters.mjs';\nimport { resolveVariant } from './variants.mjs';\nimport { isTransformProp } from '../html/utils/transform.mjs';\nimport { isWillChangeMotionValue } from '../../value/use-will-change/is.mjs';\n\nfunction animateVisualElement(visualElement, definition, options) {\n    if (options === void 0) { options = {}; }\n    visualElement.notifyAnimationStart(definition);\n    var animation;\n    if (Array.isArray(definition)) {\n        var animations = definition.map(function (variant) {\n            return animateVariant(visualElement, variant, options);\n        });\n        animation = Promise.all(animations);\n    }\n    else if (typeof definition === \"string\") {\n        animation = animateVariant(visualElement, definition, options);\n    }\n    else {\n        var resolvedDefinition = typeof definition === \"function\"\n            ? resolveVariant(visualElement, definition, options.custom)\n            : definition;\n        animation = animateTarget(visualElement, resolvedDefinition, options);\n    }\n    return animation.then(function () {\n        return visualElement.notifyAnimationComplete(definition);\n    });\n}\nfunction animateVariant(visualElement, variant, options) {\n    var _a;\n    if (options === void 0) { options = {}; }\n    var resolved = resolveVariant(visualElement, variant, options.custom);\n    var _b = (resolved || {}).transition, transition = _b === void 0 ? visualElement.getDefaultTransition() || {} : _b;\n    if (options.transitionOverride) {\n        transition = options.transitionOverride;\n    }\n    /**\n     * If we have a variant, create a callback that runs it as an animation.\n     * Otherwise, we resolve a Promise immediately for a composable no-op.\n     */\n    var getAnimation = resolved\n        ? function () { return animateTarget(visualElement, resolved, options); }\n        : function () { return Promise.resolve(); };\n    /**\n     * If we have children, create a callback that runs all their animations.\n     * Otherwise, we resolve a Promise immediately for a composable no-op.\n     */\n    var getChildAnimations = ((_a = visualElement.variantChildren) === null || _a === void 0 ? void 0 : _a.size)\n        ? function (forwardDelay) {\n            if (forwardDelay === void 0) { forwardDelay = 0; }\n            var _a = transition.delayChildren, delayChildren = _a === void 0 ? 0 : _a, staggerChildren = transition.staggerChildren, staggerDirection = transition.staggerDirection;\n            return animateChildren(visualElement, variant, delayChildren + forwardDelay, staggerChildren, staggerDirection, options);\n        }\n        : function () { return Promise.resolve(); };\n    /**\n     * If the transition explicitly defines a \"when\" option, we need to resolve either\n     * this animation or all children animations before playing the other.\n     */\n    var when = transition.when;\n    if (when) {\n        var _c = __read(when === \"beforeChildren\"\n            ? [getAnimation, getChildAnimations]\n            : [getChildAnimations, getAnimation], 2), first = _c[0], last = _c[1];\n        return first().then(last);\n    }\n    else {\n        return Promise.all([getAnimation(), getChildAnimations(options.delay)]);\n    }\n}\n/**\n * @internal\n */\nfunction animateTarget(visualElement, definition, _a) {\n    var _b;\n    var _c = _a === void 0 ? {} : _a, _d = _c.delay, delay = _d === void 0 ? 0 : _d, transitionOverride = _c.transitionOverride, type = _c.type;\n    var _e = visualElement.makeTargetAnimatable(definition), _f = _e.transition, transition = _f === void 0 ? visualElement.getDefaultTransition() : _f, transitionEnd = _e.transitionEnd, target = __rest(_e, [\"transition\", \"transitionEnd\"]);\n    var willChange = visualElement.getValue(\"willChange\");\n    if (transitionOverride)\n        transition = transitionOverride;\n    var animations = [];\n    var animationTypeState = type && ((_b = visualElement.animationState) === null || _b === void 0 ? void 0 : _b.getState()[type]);\n    var _loop_1 = function (key) {\n        var value = visualElement.getValue(key);\n        var valueTarget = target[key];\n        if (!value ||\n            valueTarget === undefined ||\n            (animationTypeState &&\n                shouldBlockAnimation(animationTypeState, key))) {\n            return \"continue\";\n        }\n        var valueTransition = __assign({ delay: delay }, transition);\n        /**\n         * Make animation instant if this is a transform prop and we should reduce motion.\n         */\n        if (visualElement.shouldReduceMotion && isTransformProp(key)) {\n            valueTransition = __assign(__assign({}, valueTransition), { type: false, delay: 0 });\n        }\n        var animation = startAnimation(key, value, valueTarget, valueTransition);\n        if (isWillChangeMotionValue(willChange)) {\n            willChange.add(key);\n            animation = animation.then(function () { return willChange.remove(key); });\n        }\n        animations.push(animation);\n    };\n    for (var key in target) {\n        _loop_1(key);\n    }\n    return Promise.all(animations).then(function () {\n        transitionEnd && setTarget(visualElement, transitionEnd);\n    });\n}\nfunction animateChildren(visualElement, variant, delayChildren, staggerChildren, staggerDirection, options) {\n    if (delayChildren === void 0) { delayChildren = 0; }\n    if (staggerChildren === void 0) { staggerChildren = 0; }\n    if (staggerDirection === void 0) { staggerDirection = 1; }\n    var animations = [];\n    var maxStaggerDuration = (visualElement.variantChildren.size - 1) * staggerChildren;\n    var generateStaggerDuration = staggerDirection === 1\n        ? function (i) {\n            if (i === void 0) { i = 0; }\n            return i * staggerChildren;\n        }\n        : function (i) {\n            if (i === void 0) { i = 0; }\n            return maxStaggerDuration - i * staggerChildren;\n        };\n    Array.from(visualElement.variantChildren)\n        .sort(sortByTreeOrder)\n        .forEach(function (child, i) {\n        animations.push(animateVariant(child, variant, __assign(__assign({}, options), { delay: delayChildren + generateStaggerDuration(i) })).then(function () { return child.notifyAnimationComplete(variant); }));\n    });\n    return Promise.all(animations);\n}\nfunction stopAnimation(visualElement) {\n    visualElement.forEachValue(function (value) { return value.stop(); });\n}\nfunction sortByTreeOrder(a, b) {\n    return a.sortNodePosition(b);\n}\n/**\n * Decide whether we should block this animation. Previously, we achieved this\n * just by checking whether the key was listed in protectedKeys, but this\n * posed problems if an animation was triggered by afterChildren and protectedKeys\n * had been set to true in the meantime.\n */\nfunction shouldBlockAnimation(_a, key) {\n    var protectedKeys = _a.protectedKeys, needsAnimating = _a.needsAnimating;\n    var shouldBlock = protectedKeys.hasOwnProperty(key) && needsAnimating[key] !== true;\n    needsAnimating[key] = false;\n    return shouldBlock;\n}\n\nexport { animateVisualElement, sortByTreeOrder, stopAnimation };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}